from ultralytics.utils.ops import non_max_suppression

@torch.no_grad()
def predict(self, x, conf=0.25, iou=0.45):
    # Forward returns feature maps, not flattened output
    feats = self.forward(x)

    # Detect head
    detect = self.layers[22]

    # Decode raw predictions from feature maps
    decoded = detect.forward_export(feats)

    # decoded: (B, num_preds, 84)  → apply NMS
    preds = non_max_suppression(
        decoded,
        conf_thres=conf,
        iou_thres=iou,
        nc=self.model.nc
    )

    return preds

#====================================================================

from ultralytics.utils.metrics import DetMetrics


@torch.no_grad()
def validate(model, dataloader, device, conf=0.25, iou=0.45):
    model.eval()

    metrics = DetMetrics()
    seen = 0

    for imgs, targets in dataloader:
        imgs = imgs.to(device)
        preds = model.infer(imgs, conf=conf, iou=iou)

        B = imgs.shape[0]
        seen += B

        # ----------------------------------------
        # Convert GT labels to YOLO expected format
        # ----------------------------------------
        gt = []
        index = 0
        for i, t in enumerate(targets):
            if len(t) == 0:
                continue

            for obj in t:
                cls = int(obj[0])
                x, y, w, h = obj[1:].tolist()

                # Convert normalized xywh → xyxy absolute pixels
                W = imgs.shape[3]
                H = imgs.shape[2]
                x1 = (x - w/2) * W
                y1 = (y - h/2) * H
                x2 = (x + w/2) * W
                y2 = (y + h/2) * H

                gt.append([i, cls, x1, y1, x2, y2])
            index += 1

        if len(gt) == 0:
            continue

        gt = torch.tensor(gt, device=device)

        # ----------------------------------------
        # Update metrics
        # ----------------------------------------
        metrics.update(preds, gt)

    final = metrics.compute(seen)
    return final


for epoch in range(epochs):
    train_one_epoch()
    
    val_results = validate(model, val_loader, device)
    print(f"Epoch {epoch+1}/{epochs}")
    print(f" Precision:   {val_results['precision']:.4f}")
    print(f" Recall:      {val_results['recall']:.4f}")
    print(f" mAP@50:      {val_results['map50']:.4f}")
    print(f" mAP@50-95:   {val_results['map']:.4f}")

