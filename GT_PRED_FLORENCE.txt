import torch
import torch.nn.functional as F


# ---------------------------------------------------------------
#  IoU Matrix (Vectorized)
# ---------------------------------------------------------------
def box_iou_matrix(a, b):
    """
    a: [N, 4]
    b: [M, 4]
    Returns IoU matrix [N, M]
    """
    inter_x1 = torch.max(a[:, None, 0], b[:, 0])
    inter_y1 = torch.max(a[:, None, 1], b[:, 1])
    inter_x2 = torch.min(a[:, None, 2], b[:, 2])
    inter_y2 = torch.min(a[:, None, 3], b[:, 3])

    inter_w = (inter_x2 - inter_x1).clamp(min=0)
    inter_h = (inter_y2 - inter_y1).clamp(min=0)
    inter_area = inter_w * inter_h

    area_a = (a[:, 2] - a[:, 0]) * (a[:, 3] - a[:, 1])
    area_b = (b[:, 2] - b[:, 0]) * (b[:, 3] - b[:, 1])

    union = area_a[:, None] + area_b - inter_area
    return inter_area / union.clamp(min=1e-6)


# ---------------------------------------------------------------
#  Class-wise NMS (Stable, YOLO-Style)
# ---------------------------------------------------------------
def classwise_nms(boxes, scores, labels, iou_thres=0.45):
    """
    Performs class-wise NMS.
    Returns final indices of boxes to keep.
    """
    device = boxes.device
    unique_classes = labels.unique()

    final_boxes = []
    final_scores = []
    final_labels = []

    for cls in unique_classes:
        cls_mask = labels == cls
        b = boxes[cls_mask]
        s = scores[cls_mask]

        if b.size(0) == 0:
            continue

        # sort by score
        order = s.argsort(descending=True)
        b = b[order]
        s = s[order]

        keep = []
        while b.size(0) > 0:
            # top box
            keep.append((b[0], s[0], cls))

            if b.size(0) == 1:
                break

            # compute IoU with remaining
            ious = box_iou_matrix(b[0:1], b[1:]).squeeze(0)
            mask = ious < iou_thres

            b = b[1:][mask]
            s = s[1:][mask]

        for bb, ss, cc in keep:
            final_boxes.append(bb)
            final_scores.append(ss)
            final_labels.append(cc)

    if len(final_boxes) == 0:
        return torch.tensor([], dtype=torch.long, device=device)

    # stack results
    final_scores = torch.stack(final_scores)
    _, sorted_idx = final_scores.sort(descending=True)

    # create fake indices (we will index manually later)
    return sorted_idx


# ---------------------------------------------------------------
#  YOLOv8 POSTPROCESSING
# ---------------------------------------------------------------
def yolov8_postprocess(outputs, conf_threshold=0.25, iou_threshold=0.45, max_detections=300):
    """
    outputs: [B, nc+4, 8400]
    returns: list of [N, 6] tensors → x1,y1,x2,y2,score,class
    """
    B, C, N = outputs.shape
    nc = C - 4

    outputs = outputs.permute(0, 2, 1)  # [B, 8400, nc+4]

    boxes = outputs[:, :, :4]           # (cx,cy,w,h)
    class_logits = outputs[:, :, 4:]    # class scores

    class_probs = torch.sigmoid(class_logits)

    # cx,cy,w,h → x1,y1,x2,y2
    cx, cy, w, h = boxes.unbind(-1)
    x1 = cx - w / 2
    y1 = cy - h / 2
    x2 = cx + w / 2
    y2 = cy + h / 2
    boxes_xyxy = torch.stack([x1, y1, x2, y2], dim=-1)

    results = []

    for i in range(B):
        bboxes = boxes_xyxy[i]        # [8400,4]
        probs = class_probs[i]        # [8400,nc]

        # pick highest class per box
        scores, labels = probs.max(dim=1)

        # confidence threshold
        mask = scores > conf_threshold
        bboxes = bboxes[mask]
        scores = scores[mask]
        labels = labels[mask]

        if bboxes.size(0) == 0:
            results.append(torch.zeros((0, 6)))
            continue

        # perform YOLO-style classwise NMS
        keep_idx = classwise_nms(bboxes, scores, labels, iou_thres=iou_threshold)

        keep_idx = keep_idx[:max_detections]  # limit detections

        final_boxes = bboxes[keep_idx]
        final_scores = scores[keep_idx]
        final_labels = labels[keep_idx].float()

        det = torch.cat([
            final_boxes,
            final_scores.unsqueeze(1),
            final_labels.unsqueeze(1)
        ], dim=1)

        results.append(det)

    return results
