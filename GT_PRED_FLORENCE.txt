import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from ultralytics import YOLO

# ================================================
# IMPORT OFFICIAL YOLOv8 LOSS FROM YOUR LOCAL COPY
# ================================================
# Make sure utils/loss.py with v8DetectionLoss is in same folder
from utils.loss import v8DetectionLoss


# =================================================
# CUSTOM YOLO MODEL WITH MANUAL BACKBONE + NECK FWD
# =================================================

class CustomYOLO(nn.Module):
    def __init__(self, ckpt):
        super().__init__()

        # Load base YOLOv8 model
        y = YOLO(ckpt)
        self.model = y.model
        self.layers = self.model.model
        self.names = self.model.names

        # Official GitHub YOLOv8 loss
        self.criterion = v8DetectionLoss(self.model)

    def forward(self, x, targets=None):
        """
        x: [B,3,h,w]
        targets: dict with keys batch_idx, cls, bboxes (xywh normalized)
        """
        layers = self.layers

        # ========= BACKBONE =============
        P3 = P4 = P5 = None
        for i, m in enumerate(layers):
            x = m(x)
            if i == 4: P3 = x
            if i == 6: P4 = x
            if i == 9: 
                P5 = x
                break

        # =======================================
        # OPTIONAL IR FUSION CAN MODIFY P3,P4,P5
        # P3,P4,P5 = self.fusion(P3, P4, P5, ir_image)
        # =======================================

        # =============== NECK: 10 - 21 ==================
        P5_up = layers[10](P5)
        F4 = layers[11]([P5_up, P4])
        P4_out = layers[12](F4)

        P4_up = layers[13](P4_out)
        F3 = layers[14]([P4_up, P3])
        P3_out = layers[15](F3)

        P3_down = layers[16](P3_out)
        F4b = layers[17]([P3_down, P4_out])
        P4b = layers[18](F4b)

        P4_down = layers[19](P4b)
        F5b = layers[20]([P4_down, P5])
        P5b = layers[21](F5b)

        # =============== DETECT HEAD =====================
        detect = layers[22]
        preds = detect([P3_out, P4b, P5b])

        if targets is None:
            return preds  # inference mode

        # Loss mode
        total_loss, loss_items = self.criterion(preds, targets)
        return preds, total_loss, loss_items


# ======================================
# SIMPLE DATASET EXAMPLE (CUSTOMIZE THIS)
# ======================================

class DummyDataset(torch.utils.data.Dataset):
    """
    Replace with your dataset.
    Must return:
      image: tensor[3,H,W]
      targets: dict(batch_idx, cls, bboxes)
    """
    def __init__(self):
        super().__init__()

    def __len__(self): return 20

    def __getitem__(self, idx):
        img = torch.randn(3, 640, 640)

        # Example: one box
        targets = {
            "batch_idx": torch.tensor([0], dtype=torch.long),
            "cls":        torch.tensor([0], dtype=torch.long),
            "bboxes":     torch.tensor([[0.5, 0.5, 0.3, 0.3]])  # xywh normalized
        }
        return img, targets


def collate_fn(batch):
    imgs = []
    batch_idx = []
    cls = []
    bboxes = []

    for b_i, (img, tgt) in enumerate(batch):
        imgs.append(img)

        t_idx = tgt["batch_idx"] + b_i
        batch_idx.append(t_idx)

        cls.append(tgt["cls"])
        bboxes.append(tgt["bboxes"])

    return (
        torch.stack(imgs),
        {
            "batch_idx": torch.cat(batch_idx),
            "cls": torch.cat(cls),
            "bboxes": torch.cat(bboxes)
        }
    )


# =========================
# MAIN TRAINING LOOP
# =========================
def train_custom():
    device = "cuda" if torch.cuda.is_available() else "cpu"

    model = CustomYOLO("yolov8n.pt").to(device)

    dataset = DummyDataset()
    loader = DataLoader(dataset, batch_size=4, shuffle=True, collate_fn=collate_fn)

    optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)

    for epoch in range(10):
        print(f"\n=== Epoch {epoch} ===")

        for imgs, targets in loader:
            imgs = imgs.to(device)
            targets = {k: v.to(device) for k, v in targets.items()}

            preds, loss, loss_items = model(imgs, targets)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            box_loss = loss_items[0].item()
            cls_loss = loss_items[1].item()
            dfl_loss = loss_items[2].item()

            print(f"loss: {loss.item():.4f}   box:{box_loss:.4f}   cls:{cls_loss:.4f}   dfl:{dfl_loss:.4f}")


if __name__ == "__main__":
    train_custom()
