import torch
import torch.nn as nn
from ultralytics import YOLO
from ultralytics.cfg import get_cfg
from ultralytics.utils import DEFAULT_CFG_PATH
from ultralytics.utils.nms import non_max_suppression


# -------------------------------------------------------
# FiLM IR conditioning module (your original design)
# -------------------------------------------------------
class FiLM_IR(nn.Module):
    def __init__(self, ir_channels=1, out_channels=512):
        super().__init__()

        self.encoder = nn.Sequential(
            nn.Conv2d(ir_channels, 32, 3, stride=2, padding=1),
            nn.BatchNorm2d(32),
            nn.SiLU(),

            nn.Conv2d(32, 64, 3, stride=2, padding=1),
            nn.BatchNorm2d(64),
            nn.SiLU(),

            nn.Conv2d(64, 128, 3, stride=2, padding=1),
            nn.BatchNorm2d(128),
            nn.SiLU(),
        )

        # project IR → gamma, beta
        self.fc = nn.Sequential(
            nn.Linear(128, 256),
            nn.SiLU(),
            nn.Linear(256, out_channels * 2),
        )

        self.out_channels = out_channels

    def forward(self, p5, ir):
        B, C, _, _ = p5.shape

        f = self.encoder(ir)                  # (B,128,H/8,W/8)
        f = torch.mean(f, dim=[2, 3])         # GAP → (B,128)

        gamma_beta = self.fc(f)               # (B, 2C)
        gamma, beta = gamma_beta.chunk(2, dim=1)

        gamma = gamma.view(B, C, 1, 1)
        beta  = beta.view(B, C, 1, 1)

        # *** residual FiLM ***
        return p5 * (1 + gamma) + beta
    


# -------------------------------------------------------
#               Custom YOLO With FiLM
# -------------------------------------------------------
class CustomYOLO(nn.Module):
    def __init__(self, weights_path="yolov8s.pt", nc=8, device=None):
        super().__init__()

        self.nc = nc
        self.reg_max = 16
        self.bbox_bins = self.reg_max * 4           # 64
        self.no = self.nc + self.bbox_bins          # 8 + 64 = 72

        # --------------------------
        # Device
        # --------------------------
        if device is None:
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.device = device

        # --------------------------
        # Load YOLOv8 model
        # --------------------------
        base = YOLO(weights_path).model
        self.model = base
        self.layers = base.model
        self.detect = self.layers[-1]

        # --------------------------
        # Update model config
        # --------------------------
        cfg = get_cfg(DEFAULT_CFG_PATH)
        cfg.nc = self.nc
        self.model.args = cfg

        # --------------------------
        # FiLM module (use P5 channels)
        # --------------------------
        p5_ch = self.layers[9].cv2.conv.out_channels  # SPPF output channels
        self.film = FiLM_IR(ir_channels=1, out_channels=p5_ch)

        # --------------------------
        # Rebuild detect head correctly
        # --------------------------
        self.rebuild_detect_head()

        self.to(self.device)



    # -------------------------------------------------------
    # Correct YOLOv8 Detect Rebuild (ONLY cv3 is changed)
    # -------------------------------------------------------
    def rebuild_detect_head(self):
        d = self.detect

        d.nc = self.nc
        d.no = self.no  # 8 classes + 64 DFL bins

        # ------ rebuild cv3 (classification head) ------
        d.cv3 = nn.ModuleList([
            nn.Sequential(
                nn.Conv2d(c, c, 3, padding=1, bias=False),
                nn.BatchNorm2d(c),
                nn.SiLU(),

                nn.Conv2d(c, c, 3, padding=1, bias=False),
                nn.BatchNorm2d(c),
                nn.SiLU(),

                nn.Conv2d(c, self.nc, 1)
            )
            for c in d.channels
        ])

        print("✔ Detect head rebuilt for", self.nc, "classes")
        print("  cv3 outputs:", [m[-1].out_channels for m in d.cv3])
        print("  Training output no =", d.no)



    # -------------------------------------------------------
    #   Manual Backbone → FiLM → Neck Reconstruction
    # -------------------------------------------------------
    def forward_features(self, x4):
        """
        Full YOLOv8 backbone + FiLM + neck
        Returns: [P3_out, P4b, P5b]
        """

        rgb = x4[:, :3]
        ir  = x4[:, 3:].to(self.device)

        layers = self.layers
        xi = rgb
        P3 = P4 = P5 = None

        # backbone (0..9)
        for i, m in enumerate(layers):
            xi = m(xi)

            if i == 4:   P3 = xi
            if i == 6:   P4 = xi
            if i == 9:
                P5 = xi
                break

        # ----- Apply FiLM to P5 -----
        P5 = self.film(P5, ir)

        # ----- Neck -----
        P5_up = layers[10](P5)
        F4 = layers[11]([P5_up, P4])
        P4_out = layers[12](F4)

        P4_up = layers[13](P4_out)
        F3 = layers[14]([P4_up, P3])
        P3_out = layers[15](F3)

        P3_down = layers[16](P3_out)
        F4b = layers[17]([P3_down, P4_out])
        P4b = layers[18](F4b)

        P4_down = layers[19](P4b)
        F5b = layers[20]([P4_down, P5])
        P5b = layers[21](F5b)

        return [P3_out, P4b, P5b]



    # -------------------------------------------------------
    # FORWARD = detect(features)
    # Training → raw 72-channel output
    # Eval     → decoded 12-channel output
    # -------------------------------------------------------
    def forward(self, x4):
        feats = self.forward_features(x4)
        return self.detect(feats)



    # -------------------------------------------------------
    # INFERENCE WRAPPER
    # -------------------------------------------------------
    @torch.no_grad()
    def predict(self, x, conf=0.25, iou=0.45, max_det=300):
        self.eval()

        raw = self.forward(x)   # (B, 12, 8400)

        return non_max_suppression(
            raw,
            conf_thres=conf,
            iou_thres=iou,
            max_det=max_det
        )

