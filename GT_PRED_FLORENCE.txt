from ultralytics.utils.ops import non_max_suppression

@torch.no_grad()
def decode(self, feats):
    """
    Convert raw YOLOv8 head outputs (P3,P4,P5) into decoded xyxy + score + cls.
    feats = [P3_out, P4b, P5b]
    """

    detect = self.layers[22]  # YOLOv8 Detect head

    stride = detect.stride
    reg_max = detect.reg_max
    nc = detect.nc
    no = nc + reg_max * 4
    device = feats[0].device

    # -----------------------------------------------------
    # Build anchors for all levels (80x80, 40x40, 20x20)
    # -----------------------------------------------------
    anchor_points, stride_tensor = make_anchors(feats, stride, 0.5)

    # -----------------------------------------------------
    # Flatten all feature maps (merge all anchors)
    # -----------------------------------------------------
    B = feats[0].shape[0]
    feats = [f.view(B, no, -1) for f in feats]  # (B,84,H*W)

    # Split bbox distribution + class logits
    pred_distri, pred_scores = torch.cat(feats, dim=2).split((reg_max * 4, nc), dim=1)

    # Move channels to last dim
    pred_distri = pred_distri.permute(0, 2, 1)  # (B,N,regmax*4)
    pred_scores = pred_scores.permute(0, 2, 1).sigmoid()

    # -----------------------------------------------------
    # DFL decoding: convert distribution → distances
    # -----------------------------------------------------
    proj = torch.arange(reg_max, device=device, dtype=torch.float32)
    pred_d = pred_distri.view(B, -1, 4, reg_max).softmax(3)
    pred_d = pred_d.matmul(proj)  # (B,N,4)

    # -----------------------------------------------------
    # Convert distances → xyxy boxes
    # -----------------------------------------------------
    boxes = dist2bbox(pred_d, anchor_points, xywh=False)
    boxes *= stride_tensor  # pixel scaling

    # -----------------------------------------------------
    # Final YOLO output: (x1,y1,x2,y2, score, cls...)
    # -----------------------------------------------------
    out = torch.cat((boxes, pred_scores), dim=-1)

    return out  # shape (B, N, 4+nc)


@torch.no_grad()
def predict(self, x, conf=0.25, iou=0.45, max_det=300):
    # get raw multi-scale outputs
    feats = self.forward(x)

    # decode them
    decoded = self.decode(feats)  # (B,N,4+nc)

    # run YOLO NMS
    results = non_max_suppression(
        decoded,
        conf_thres=conf,
        iou_thres=iou,
        max_det=max_det,
        nc=self.model.nc
    )

    return results


#====================================================================

from ultralytics.utils.metrics import DetMetrics


@torch.no_grad()
def validate(model, dataloader, device, conf=0.25, iou=0.45):
    model.eval()

    metrics = DetMetrics()
    seen = 0

    for imgs, targets in dataloader:
        imgs = imgs.to(device)
        preds = model.infer(imgs, conf=conf, iou=iou)

        B = imgs.shape[0]
        seen += B

        # ----------------------------------------
        # Convert GT labels to YOLO expected format
        # ----------------------------------------
        gt = []
        index = 0
        for i, t in enumerate(targets):
            if len(t) == 0:
                continue

            for obj in t:
                cls = int(obj[0])
                x, y, w, h = obj[1:].tolist()

                # Convert normalized xywh → xyxy absolute pixels
                W = imgs.shape[3]
                H = imgs.shape[2]
                x1 = (x - w/2) * W
                y1 = (y - h/2) * H
                x2 = (x + w/2) * W
                y2 = (y + h/2) * H

                gt.append([i, cls, x1, y1, x2, y2])
            index += 1

        if len(gt) == 0:
            continue

        gt = torch.tensor(gt, device=device)

        # ----------------------------------------
        # Update metrics
        # ----------------------------------------
        metrics.update(preds, gt)

    final = metrics.compute(seen)
    return final


for epoch in range(epochs):
    train_one_epoch()
    
    val_results = validate(model, val_loader, device)
    print(f"Epoch {epoch+1}/{epochs}")
    print(f" Precision:   {val_results['precision']:.4f}")
    print(f" Recall:      {val_results['recall']:.4f}")
    print(f" mAP@50:      {val_results['map50']:.4f}")
    print(f" mAP@50-95:   {val_results['map']:.4f}")



