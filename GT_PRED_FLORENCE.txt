from ultralytics.utils.nms import non_max_suppression

@torch.no_grad()
def yolo_official_postprocess(model, x, conf=0.25, iou=0.45, max_det=300):
    """
    model: CustomYOLO (your model)
    x     : input image (4-channel)
    Returns YOLOv8-style detections.
    """

    model.eval()

    # Detect.forward() returns DFL-decoded predictions in eval mode
    raw = model(x)                     # shape: (B, 12, HW)

    # convert to list of NMS outputs
    preds = non_max_suppression(
        raw.permute(0, 2, 1),          # (B, HW, 12)
        conf_thres=conf,
        iou_thres=iou,
        max_det=max_det,
        nc=model.nc                    # your number of classes
    )

    # preds[i] has shape: (N, 6): [x1,y1,x2,y2,conf,class]
    return preds



@torch.no_grad()
def validate_model(model, val_loader, device="cuda", conf=0.25, iou_thres=0.5):
    model.eval()
    tp = fp = fn = 0
    correct_cls = 0
    total_cls = 0

    for imgs4, labels in tqdm(val_loader, desc="Validating"):
        imgs4 = imgs4.to(device)
        H, W = imgs4.shape[2], imgs4.shape[3]

        # 1. Get detect output
        feats = model.forward_features(imgs4)
        raw = model.detect(feats)

        preds = yolov8_postprocess(raw, conf_threshold=conf)

        for i, det in enumerate(preds):
            gt = labels[i].to(device)  # [N,5]

            if gt.numel() == 0:
                if det.size(0) > 0:
                    fp += det.size(0)
                continue

            # Convert GT to pixel coords
            gx = gt[:,1] * W
            gy = gt[:,2] * H
            gw = gt[:,3] * W
            gh = gt[:,4] * H

            x1 = gx - gw/2; y1 = gy - gh/2
            x2 = gx + gw/2; y2 = gy + gh/2
            gt_box = torch.stack([x1,y1,x2,y2], dim=1)

            # Predictions
            if det.size(0) == 0:
                fn += gt.size(0)
                continue

            pred_box = det[:, :4]
            pred_cls = det[:, 5].long()

            # IoU matching
            iou = box_iou(pred_box, gt_box)
            max_iou, idx = iou.max(dim=1)

            match = max_iou > iou_thres

            tp += match.sum().item()
            fp += (~match).sum().item()
            fn += gt.size(0) - match.sum().item()

            # Class accuracy
            matched_gt_cls = gt[idx][match][:,0].long()
            matched_pred_cls = pred_cls[match]

            correct_cls += (matched_pred_cls == matched_gt_cls).sum().item()
            total_cls += matched_pred_cls.numel()

    map50 = tp / (tp + fp + 1e-6)
    cls_acc = correct_cls / (total_cls + 1e-6)

    return map50, cls_acc

