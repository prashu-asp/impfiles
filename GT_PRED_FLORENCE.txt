from ultralytics.utils.ops import non_max_suppression

@torch.no_grad()
def predict(self, x, conf=0.25, iou=0.45, max_det=300):
    """
    Convert raw model output into boxes + scores + classes.
    Similar to Ultralytics predict().
    """
    preds = self.forward(x)   # raw predictions from Detect head

    # preds is a list of feature maps → combine along anchor dimension
    # Detect.forward returns (B, no, H*W) for each level
    detect = self.layers[22]   # final detect head
    
    # This handles bbox decoding + score formatting
    decoded = detect.predict(preds, batch=x.shape[0])

    # Now decoded → (B, total_preds, 6) → [x1,y1,x2,y2,score,class]
    results = []
    for i in range(len(decoded)):
        boxes = non_max_suppression(
            decoded[i].unsqueeze(0),  # shape: (1, N, 6)
            conf_thres=conf,
            iou_thres=iou,
            max_det=max_det
        )[0]

        results.append(boxes)  # tensor(N,6)

    return results

#====================================================================

from ultralytics.utils.metrics import DetMetrics


@torch.no_grad()
def validate(model, dataloader, device, conf=0.25, iou=0.45):
    model.eval()

    metrics = DetMetrics()
    seen = 0

    for imgs, targets in dataloader:
        imgs = imgs.to(device)
        preds = model.infer(imgs, conf=conf, iou=iou)

        B = imgs.shape[0]
        seen += B

        # ----------------------------------------
        # Convert GT labels to YOLO expected format
        # ----------------------------------------
        gt = []
        index = 0
        for i, t in enumerate(targets):
            if len(t) == 0:
                continue

            for obj in t:
                cls = int(obj[0])
                x, y, w, h = obj[1:].tolist()

                # Convert normalized xywh → xyxy absolute pixels
                W = imgs.shape[3]
                H = imgs.shape[2]
                x1 = (x - w/2) * W
                y1 = (y - h/2) * H
                x2 = (x + w/2) * W
                y2 = (y + h/2) * H

                gt.append([i, cls, x1, y1, x2, y2])
            index += 1

        if len(gt) == 0:
            continue

        gt = torch.tensor(gt, device=device)

        # ----------------------------------------
        # Update metrics
        # ----------------------------------------
        metrics.update(preds, gt)

    final = metrics.compute(seen)
    return final


for epoch in range(epochs):
    train_one_epoch()
    
    val_results = validate(model, val_loader, device)
    print(f"Epoch {epoch+1}/{epochs}")
    print(f" Precision:   {val_results['precision']:.4f}")
    print(f" Recall:      {val_results['recall']:.4f}")
    print(f" mAP@50:      {val_results['map50']:.4f}")
    print(f" mAP@50-95:   {val_results['map']:.4f}")


